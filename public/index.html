<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Assistant - Live Conversation</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            overflow: hidden;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            text-align: center;
            max-width: 700px;
            width: 90%;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.8;
            margin-bottom: 30px;
        }

        .conversation-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .status-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .mic-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(255, 107, 107, 0.4);
        }

        .mic-button.listening {
            background: linear-gradient(45deg, #2ed573, #17c0eb);
            animation: pulse 2s infinite;
        }

        .mic-button.speaking {
            background: linear-gradient(45deg, #ffa502, #ff6348);
            animation: glow 1.5s infinite alternate;
        }

        .mic-button.connecting {
            background: linear-gradient(45deg, #a55eea, #26de81);
            animation: spin 2s linear infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 8px 25px rgba(46, 213, 115, 0.3); }
            50% { transform: scale(1.1); box-shadow: 0 12px 35px rgba(46, 213, 115, 0.6); }
            100% { transform: scale(1); box-shadow: 0 8px 25px rgba(46, 213, 115, 0.3); }
        }

        @keyframes glow {
            0% { box-shadow: 0 8px 25px rgba(255, 165, 2, 0.3); }
            100% { box-shadow: 0 12px 35px rgba(255, 165, 2, 0.8); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status {
            font-size: 1.2rem;
            font-weight: 500;
            min-height: 30px;
            transition: all 0.3s ease;
        }

        .status.ready { color: #2ed573; }
        .status.listening { color: #17c0eb; }
        .status.speaking { color: #ffa502; }
        .status.connecting { color: #a55eea; }
        .status.error { color: #ff6b6b; }

        .volume-indicator {
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 0 auto;
        }

        .volume-bar {
            height: 100%;
            background: linear-gradient(90deg, #2ed573, #ffa502, #ff6b6b);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 4px;
        }

        .conversation-display {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            overflow-y: auto;
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 300px;
        }

        .message {
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease;
        }

        .message.user {
            background: linear-gradient(45deg, #667eea, #764ba2);
            align-self: flex-end;
            margin-left: auto;
        }

        .message.ai {
            background: linear-gradient(45deg, #2ed573, #17c0eb);
            align-self: flex-start;
            margin-right: auto;
        }

        .message.system {
            background: rgba(255, 255, 255, 0.1);
            align-self: center;
            font-style: italic;
            opacity: 0.8;
            font-size: 0.9rem;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .error {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border: 1px solid rgba(255, 107, 107, 0.3);
            font-size: 0.9rem;
        }

        .instructions {
            margin-top: 20px;
            opacity: 0.7;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 107, 107, 0.2);
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            margin-bottom: 10px;
        }

        .live-dot {
            width: 8px;
            height: 8px;
            background: #ff6b6b;
            border-radius: 50%;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        @media (max-width: 768px) {
            .container {
                padding: 30px 20px;
                height: 85vh;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .mic-button {
                width: 80px;
                height: 80px;
                font-size: 2rem;
            }

            .conversation-display {
                max-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎤 Live AI Assistant</h1>
        <p class="subtitle">Real-time conversation with Google Gemini</p>
        
        <div class="conversation-area">
            <div class="status-section">
                <div class="live-indicator" id="liveIndicator" style="display: none;">
                    <div class="live-dot"></div>
                    LIVE
                </div>
                
                <button class="mic-button" id="micButton">
                    🎤
                </button>
                
                <div class="status ready" id="status">Click to start live conversation</div>
                
                <div class="volume-indicator">
                    <div class="volume-bar" id="volumeBar"></div>
                </div>
            </div>
            
            <div class="conversation-display" id="conversationDisplay">
                <div class="message system">Welcome! Click the microphone to start a live conversation with AI.</div>
            </div>
        </div>
        
        <div class="controls">
            <button class="control-btn" id="clearBtn">Clear Chat</button>
            <button class="control-btn" id="muteBtn">Mute</button>
            <button class="control-btn" id="testBtn">Test Text</button>
            <button class="control-btn" id="testAudioBtn">Test Audio</button>
            <button class="control-btn" id="settingsBtn">Settings</button>
        </div>
        
        <div class="instructions">
            <strong>Live Mode:</strong> Speak naturally - AI responds immediately like a real conversation!<br>
            <small>If audio isn't working, try the "Test Text" button to verify connection.</small>
        </div>
    </div>

    <script>
        class LiveVoiceAssistant {
            constructor() {
                this.socket = io();
                this.mediaRecorder = null;
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.isConversationActive = false;
                this.isListening = false;
                this.isMuted = false;
                this.audioChunks = [];
                this.streamingInterval = null;
                this.audioWorkletNode = null;
                this.scriptProcessor = null;
                this.microphoneSource = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupSocketListeners();
                this.checkMicrophonePermission();
            }
            
            initializeElements() {
                this.micButton = document.getElementById('micButton');
                this.status = document.getElementById('status');
                this.conversationDisplay = document.getElementById('conversationDisplay');
                this.volumeBar = document.getElementById('volumeBar');
                this.liveIndicator = document.getElementById('liveIndicator');
                this.clearBtn = document.getElementById('clearBtn');
                this.muteBtn = document.getElementById('muteBtn');
                this.testBtn = document.getElementById('testBtn');
                this.testAudioBtn = document.getElementById('testAudioBtn');
                this.settingsBtn = document.getElementById('settingsBtn');
            }
            
            setupEventListeners() {
                this.micButton.addEventListener('click', () => this.toggleConversation());
                this.clearBtn.addEventListener('click', () => this.clearConversation());
                this.muteBtn.addEventListener('click', () => this.toggleMute());
                this.testBtn.addEventListener('click', () => this.testTextInput());
                this.testAudioBtn.addEventListener('click', () => this.testAudioPlayback());
                this.settingsBtn.addEventListener('click', () => this.showSettings());
            }
            
            setupSocketListeners() {
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.updateStatus('Connected - Ready for live conversation!', 'ready');
                });
                
                this.socket.on('disconnect', () => {
                    console.log('Disconnected from server');
                    this.updateStatus('Disconnected from server', 'error');
                    this.stopConversation();
                });
                
                this.socket.on('setup-complete', () => {
                    console.log('Gemini setup completed');
                    this.addMessage('AI is ready to chat!', 'system');
                });
                
                this.socket.on('conversation-started', () => {
                    console.log('Live conversation started');
                    this.isConversationActive = true;
                    this.liveIndicator.style.display = 'inline-flex';
                    this.updateStatus('Live conversation active - Speak naturally!', 'listening');
                    this.micButton.classList.add('listening');
                    this.startContinuousListening();
                });
                
                this.socket.on('conversation-ended', () => {
                    console.log('Live conversation ended');
                    this.stopConversation();
                });
                
                this.socket.on('user-transcription', (data) => {
                    console.log('User said:', data.text);
                    this.addMessage(data.text, 'user');
                });
                
                this.socket.on('ai-response', (data) => {
                    console.log('💬 AI Response:', data.text);
                    this.addMessage(data.text, 'ai');
                });
                
                this.socket.on('ai-audio-response', (data) => {
                    console.log('🎵 Received combined AI audio response');
                    console.log('📊 Audio data details:', {
                        type: typeof data,
                        hasAudio: !!data.audio,
                        audioLength: data.audio ? data.audio.length : 'N/A',
                        format: data.format,
                        dataKeys: Object.keys(data)
                    });
                    
                    // Validate the audio data
                    if (!data || !data.audio) {
                        console.error('❌ Invalid audio response data:', data);
                        this.showError('Invalid audio response received');
                        return;
                    }
                    
                    // Test if the base64 data is valid
                    try {
                        const testDecode = atob(data.audio);
                        console.log('✅ Base64 audio data is valid, decoded length:', testDecode.length);
                        
                        // Check if it looks like WAV data
                        if (testDecode.length >= 12) {
                            const header = testDecode.substring(0, 12);
                            const riff = header.substring(0, 4);
                            const wave = header.substring(8, 12);
                            console.log('📋 Audio headers:', { riff, wave, isWAV: riff === 'RIFF' && wave === 'WAVE' });
                        }
                        
                    } catch (error) {
                        console.error('❌ Invalid base64 audio data:', error);
                        this.showError('Invalid audio data format');
                        return;
                    }
                    
                    console.log('🎯 Attempting to play audio response...');
                    this.playAudioResponse(data);
                });
                
                this.socket.on('generation-complete', () => {
                    console.log('Generation completed');
                    // AI has finished generating the response
                });
                
                this.socket.on('turn-complete', () => {
                    console.log('Turn completed');
                    if (this.isConversationActive) {
                        this.updateStatus('Listening...', 'listening');
                        this.micButton.classList.remove('speaking');
                        this.micButton.classList.add('listening');
                    }
                });
                
                this.socket.on('turn-interrupted', () => {
                    console.log('Turn interrupted');
                    if (this.isConversationActive) {
                        this.updateStatus('Listening...', 'listening');
                        this.micButton.classList.remove('speaking');
                        this.micButton.classList.add('listening');
                    }
                });
                
                this.socket.on('error', (error) => {
                    console.error('Server error:', error);
                    this.showError('Error: ' + error.message);
                    this.stopConversation();
                });
            }
            
            async checkMicrophonePermission() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());
                    this.updateStatus('Microphone ready - Click to start!', 'ready');
                } catch (error) {
                    this.showError('Microphone access denied. Please allow microphone access and refresh the page.');
                }
            }
            
            async toggleConversation() {
                if (!this.isConversationActive) {
                    await this.startConversation();
                } else {
                    this.stopConversation();
                }
            }
            
            async startConversation() {
                try {
                    this.updateStatus('Starting live conversation...', 'connecting');
                    this.micButton.classList.add('connecting');
                    this.micButton.innerHTML = '⏳';
                    
                    // Start the live conversation with server
                    this.socket.emit('start-conversation');
                    
                } catch (error) {
                    console.error('Error starting conversation:', error);
                    this.showError('Failed to start conversation: ' + error.message);
                    this.resetButton();
                }
            }
            
            async startContinuousListening() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });
                    
                    this.setupAudioAnalysis(stream);
                    this.setupAudioStreaming(stream);
                    
                    this.micButton.innerHTML = '🎙️';
                    
                } catch (error) {
                    console.error('Error starting continuous listening:', error);
                    this.showError('Failed to start listening: ' + error.message);
                    this.stopConversation();
                }
            }
            
            setupAudioAnalysis(stream) {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                this.analyser = this.audioContext.createAnalyser();
                this.microphone = this.audioContext.createMediaStreamSource(stream);
                
                this.analyser.fftSize = 256;
                this.microphone.connect(this.analyser);
                
                this.visualizeAudio();
            }
            
            setupAudioStreaming(stream) {
                // Use ScriptProcessorNode to capture raw audio instead of MediaRecorder
                try {
                    if (!this.audioContext || this.audioContext.state === 'closed') {
                        // Use default sample rate (typically 44100 or 48000)
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const source = this.audioContext.createMediaStreamSource(stream);
                    const processor = this.audioContext.createScriptProcessor(4096, 1, 1);
                    
                    processor.onaudioprocess = (event) => {
                        if (!this.isConversationActive || this.isMuted) return;
                        const inputBuffer = event.inputBuffer.getChannelData(0);
                        const pcm16 = this.downsampleAndConvert(inputBuffer, this.audioContext.sampleRate, 16000);
                        if (pcm16) {
                            const base64Audio = this.int16ToBase64(pcm16);
                            this.socket.emit('audio-stream', base64Audio);
                        }
                    };
                    
                    source.connect(processor);
                    processor.connect(this.audioContext.destination); // Keep processor alive
                    
                    // Save references for cleanup
                    this.scriptProcessor = processor;
                    this.microphoneSource = source;
                    
                    console.log('🎙️ Audio streaming (ScriptProcessor) initialized', {
                        inputSampleRate: this.audioContext.sampleRate
                    });
                } catch (error) {
                    console.error('❌ Error setting up audio streaming:', error);
                    this.showError('Audio streaming setup failed: ' + error.message);
                }
            }
            
            downsampleAndConvert(buffer, inputSampleRate, outputSampleRate) {
                if (outputSampleRate === inputSampleRate) {
                    // Direct convert to Int16
                    const int16 = new Int16Array(buffer.length);
                    for (let i = 0; i < buffer.length; i++) {
                        const s = Math.max(-1, Math.min(1, buffer[i]));
                        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    return int16;
                }
                const ratio = inputSampleRate / outputSampleRate;
                const newLength = Math.round(buffer.length / ratio);
                const int16 = new Int16Array(newLength);
                let offset = 0;
                for (let i = 0; i < newLength; i++) {
                    const nextOffset = Math.round((i + 1) * ratio);
                    let sum = 0;
                    let count = 0;
                    for (; offset < nextOffset && offset < buffer.length; offset++) {
                        sum += buffer[offset];
                        count++;
                    }
                    const avg = sum / count;
                    const s = Math.max(-1, Math.min(1, avg));
                    int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
                return int16;
            }
            
            int16ToBase64(int16Array) {
                const byteArray = new Uint8Array(int16Array.buffer);
                let binary = '';
                for (let i = 0; i < byteArray.byteLength; i++) {
                    binary += String.fromCharCode(byteArray[i]);
                }
                return btoa(binary);
            }
            
            visualizeAudio() {
                if (!this.isConversationActive || !this.analyser) return;
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                this.analyser.getByteFrequencyData(dataArray);
                
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                const percentage = (average / 255) * 100;
                
                this.volumeBar.style.width = percentage + '%';
                
                requestAnimationFrame(() => this.visualizeAudio());
            }
            
            async playAudioResponse(audioData) {
                try {
                    console.log('🎵 Playing AI audio response...');
                    
                    // Handle different audio data formats
                    let base64Audio;
                    let format = 'wav'; // default
                    
                    if (typeof audioData === 'string') {
                        base64Audio = audioData;
                    } else if (audioData.audio) {
                        base64Audio = audioData.audio;
                        format = audioData.format || 'wav';
                    } else {
                        console.error('❌ Invalid audio data format:', audioData);
                        return;
                    }
                    
                    console.log('🔧 Processing audio data:', { 
                        format, 
                        length: base64Audio.length,
                        preview: base64Audio.substring(0, 50) + '...'
                    });
                    
                    // Update UI to show AI is speaking
                    this.updateStatus('AI is speaking...', 'speaking');
                    this.micButton.classList.remove('listening');
                    this.micButton.classList.add('speaking');
                    
                    // Convert base64 to blob and play
                    const success = await this.playAudioBlob(base64Audio);
                    
                    if (!success) {
                        console.error('❌ All audio playback methods failed');
                        this.showError('Failed to play AI audio response');
                    }
                    
                } catch (error) {
                    console.error('❌ Error in playAudioResponse:', error);
                    this.showError('Failed to play AI audio response: ' + error.message);
                } finally {
                    // Always return to listening state
                    setTimeout(() => {
                        if (this.isConversationActive) {
                            this.updateStatus('Listening...', 'listening');
                            this.micButton.classList.remove('speaking');
                            this.micButton.classList.add('listening');
                        }
                    }, 100);
                }
            }
            
            async playAudioBlob(base64Audio) {
                try {
                    console.log('🎵 Creating audio blob from base64 data...');
                    
                    // Decode base64 to binary
                    const binaryString = atob(base64Audio);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    console.log('✅ Binary data created:', bytes.length, 'bytes');
                    
                    // Validate WAV header
                    if (bytes.length < 44) {
                        throw new Error('Audio data too short to be valid WAV');
                    }
                    
                    const riffHeader = String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]);
                    const waveHeader = String.fromCharCode(bytes[8], bytes[9], bytes[10], bytes[11]);
                    
                    if (riffHeader !== 'RIFF' || waveHeader !== 'WAVE') {
                        console.warn('⚠️ Invalid WAV headers, but attempting to play anyway');
                    } else {
                        console.log('✅ Valid WAV headers detected');
                    }
                    
                    // First try Web Audio API decode (handles non-standard sample rates like 24 kHz)
                    try {
                        const success = await this.playWithWebAudio(bytes.buffer);
                        if (success) return true;
                    } catch (e) {
                        console.warn('⚠️ WebAudio decode failed, falling back to HTMLAudio', e.message);
                    }

                    // Fallback to HTML <audio> element – requires browser-supported mimeType (often 44.1 kHz / 48 kHz)
                    const mimeTypes = [
                        'audio/wav',
                        'audio/x-wav', 
                        'audio/wave'
                    ];
                    for (const mimeType of mimeTypes) {
                        try {
                            console.log(`🔄 Trying MIME type: ${mimeType}`);
                            const audioBlob = new Blob([bytes], { type: mimeType });
                            const audioUrl = URL.createObjectURL(audioBlob);
                            const success = await this.playAudioUrl(audioUrl, mimeType);
                            if (success) {
                                console.log(`✅ Successfully played with MIME type: ${mimeType}`);
                                return true;
                            }
                            URL.revokeObjectURL(audioUrl);
                        } catch (error) {
                            console.warn(`⚠️ Failed with MIME type ${mimeType}:`, error.message);
                        }
                    }
                    
                    return false;
                    
                } catch (error) {
                    console.error('❌ Error creating audio blob:', error);
                    return false;
                }
            }
            
            async playAudioUrl(audioUrl, mimeType) {
                return new Promise((resolve) => {
                    console.log(`🎵 Starting playAudioUrl for ${mimeType}`);
                    const audio = new Audio();
                    let hasResolved = false;
                    let playbackStarted = false;
                    
                    const cleanup = () => {
                        if (!hasResolved) {
                            hasResolved = true;
                            URL.revokeObjectURL(audioUrl);
                        }
                    };
                    
                    const resolveSuccess = () => {
                        if (!hasResolved) {
                            hasResolved = true;
                            console.log(`✅ Audio playback successful for ${mimeType}`);
                            resolve(true);
                        }
                    };
                    
                    const resolveFailure = (reason) => {
                        if (!hasResolved) {
                            hasResolved = true;
                            console.log(`❌ Audio playback failed for ${mimeType}: ${reason}`);
                            cleanup();
                            resolve(false);
                        }
                    };
                    
                    // Set up event listeners with detailed logging
                    audio.onloadstart = () => {
                        console.log(`🔄 Loading started for ${mimeType}`);
                    };
                    
                    audio.onloadedmetadata = () => {
                        console.log(`📊 Metadata loaded for ${mimeType}:`, {
                            duration: audio.duration,
                            readyState: audio.readyState,
                            networkState: audio.networkState
                        });
                    };
                    
                    audio.oncanplay = () => {
                        console.log(`✅ Can play ${mimeType} - duration: ${audio.duration}s`);
                    };
                    
                    audio.oncanplaythrough = () => {
                        console.log(`✅ Can play through ${mimeType}`);
                    };
                    
                    audio.onplay = () => {
                        console.log(`🎵 Playback started for ${mimeType}`);
                        playbackStarted = true;
                    };
                    
                    audio.onplaying = () => {
                        console.log(`🎵 Playing ${mimeType}`);
                    };
                    
                    audio.onended = () => {
                        console.log(`✅ Playback ended for ${mimeType}`);
                        cleanup();
                        this.onAudioPlaybackEnded();
                        resolveSuccess();
                    };
                    
                    audio.onerror = (error) => {
                        console.error(`❌ Audio error for ${mimeType}:`, {
                            error: error,
                            audioError: audio.error,
                            code: audio.error ? audio.error.code : 'unknown',
                            message: audio.error ? audio.error.message : 'unknown',
                            readyState: audio.readyState,
                            networkState: audio.networkState
                        });
                        resolveFailure(`Audio error: ${audio.error ? audio.error.message : 'unknown'}`);
                    };
                    
                    audio.onabort = () => {
                        console.warn(`⚠️ Audio aborted for ${mimeType}`);
                        resolveFailure('Audio aborted');
                    };
                    
                    audio.onstalled = () => {
                        console.warn(`⚠️ Audio stalled for ${mimeType}`);
                    };
                    
                    audio.onsuspend = () => {
                        console.warn(`⚠️ Audio suspended for ${mimeType}`);
                    };
                    
                    audio.onwaiting = () => {
                        console.warn(`⚠️ Audio waiting for ${mimeType}`);
                    };
                    
                    // Set timeout for loading
                    const timeoutId = setTimeout(() => {
                        if (!playbackStarted) {
                            console.error(`⏰ Timeout loading ${mimeType} - no playback started`);
                            resolveFailure('Timeout - no playback started');
                        }
                    }, 10000); // Increased timeout to 10 seconds
                    
                    // Clear timeout on successful play
                    audio.addEventListener('play', () => {
                        clearTimeout(timeoutId);
                    });
                    
                    // Set audio properties
                    audio.src = audioUrl;
                    audio.volume = 1.0;
                    audio.preload = 'auto';
                    
                    console.log(`🔧 Audio element configured for ${mimeType}:`, {
                        src: audioUrl.substring(0, 50) + '...',
                        volume: audio.volume,
                        preload: audio.preload
                    });
                    
                    // Test if browser can play this type
                    const canPlayResult = audio.canPlayType(mimeType);
                    console.log(`🧪 Browser support for ${mimeType}: "${canPlayResult}"`);
                    
                    if (canPlayResult === '') {
                        console.warn(`⚠️ Browser reports no support for ${mimeType}`);
                    }
                    
                    // Attempt to play
                    console.log(`🎵 Attempting to play ${mimeType}...`);
                    audio.play().then(() => {
                        console.log(`✅ Play promise resolved for ${mimeType}`);
                    }).catch((playError) => {
                        console.error(`❌ Play promise rejected for ${mimeType}:`, playError);
                        clearTimeout(timeoutId);
                        resolveFailure(`Play failed: ${playError.message}`);
                    });
                });
            }
            
            onAudioPlaybackEnded() {
                // Return to listening state if conversation is still active
                if (this.isConversationActive) {
                    this.updateStatus('Listening...', 'listening');
                    this.micButton.classList.remove('speaking');
                    this.micButton.classList.add('listening');
                }
            }
            
            testTextInput() {
                if (!this.isConversationActive) {
                    this.showError('Please start a conversation first');
                    return;
                }
                
                const testMessage = prompt('Enter a test message to send to AI:');
                if (testMessage) {
                    console.log('Sending test message:', testMessage);
                    this.addMessage(testMessage, 'user');
                    this.socket.emit('send-text', testMessage);
                }
            }
            
            testAudioPlayback() {
                console.log('🧪 Testing audio playback with generated tone...');
                
                try {
                    // Create a simple test tone using Web Audio API
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const sampleRate = 24000;
                    const duration = 1; // 1 second
                    const frequency = 440; // A4 note
                    const samples = sampleRate * duration;
                    
                    // Create audio buffer
                    const audioBuffer = audioContext.createBuffer(1, samples, sampleRate);
                    const channelData = audioBuffer.getChannelData(0);
                    
                    // Generate sine wave
                    for (let i = 0; i < samples; i++) {
                        const t = i / sampleRate;
                        channelData[i] = Math.sin(2 * Math.PI * frequency * t) * 0.3; // 30% volume
                    }
                    
                    console.log('🎵 Generated test audio buffer:', {
                        duration: audioBuffer.duration,
                        sampleRate: audioBuffer.sampleRate,
                        channels: audioBuffer.numberOfChannels
                    });
                    
                    // Play the test audio
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);
                    
                    source.onended = () => {
                        console.log('✅ Test audio playback completed');
                        audioContext.close();
                    };
                    
                    console.log('🎵 Playing test audio...');
                    source.start(0);
                    
                } catch (error) {
                    console.error('❌ Error generating test audio:', error);
                    this.showError('Failed to generate test audio: ' + error.message);
                }
            }
            
            stopConversation() {
                this.isConversationActive = false;
                this.liveIndicator.style.display = 'none';
                
                // Stop mediaRecorder if it exists
                if (this.mediaRecorder) {
                    if (this.mediaRecorder.state === 'recording') {
                        this.mediaRecorder.stop();
                    }
                    if (this.mediaRecorder.stream) {
                        this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    }
                    this.mediaRecorder = null;
                }
                
                // Disconnect ScriptProcessor and microphone source if they exist
                if (this.scriptProcessor) {
                    try {
                        this.scriptProcessor.disconnect();
                    } catch (e) {
                        console.warn('⚠️ Error disconnecting scriptProcessor', e);
                    }
                    this.scriptProcessor = null;
                }
                if (this.microphoneSource) {
                    try {
                        this.microphoneSource.disconnect();
                    } catch (e) {
                        console.warn('⚠️ Error disconnecting microphoneSource', e);
                    }
                    this.microphoneSource = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                if (this.streamingInterval) {
                    clearInterval(this.streamingInterval);
                    this.streamingInterval = null;
                }
                
                this.socket.emit('stop-conversation');
                this.resetButton();
                this.updateStatus('Conversation ended - Click to start again', 'ready');
                this.volumeBar.style.width = '0%';
            }
            
            resetButton() {
                this.micButton.classList.remove('listening', 'speaking', 'connecting');
                this.micButton.innerHTML = '🎤';
            }
            
            addMessage(text, type) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                messageDiv.textContent = text;
                
                this.conversationDisplay.appendChild(messageDiv);
                this.conversationDisplay.scrollTop = this.conversationDisplay.scrollHeight;
            }
            
            updateStatus(message, type) {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
            }
            
            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                
                this.conversationDisplay.appendChild(errorDiv);
                this.conversationDisplay.scrollTop = this.conversationDisplay.scrollHeight;
                
                setTimeout(() => {
                    errorDiv.remove();
                }, 5000);
            }
            
            clearConversation() {
                this.conversationDisplay.innerHTML = '<div class="message system">Conversation cleared. Continue speaking!</div>';
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                this.muteBtn.textContent = this.isMuted ? 'Unmute' : 'Mute';
                this.muteBtn.style.background = this.isMuted ? 'rgba(255, 107, 107, 0.3)' : 'rgba(255, 255, 255, 0.2)';
                
                if (this.isMuted) {
                    this.addMessage('Microphone muted', 'system');
                } else {
                    this.addMessage('Microphone unmuted', 'system');
                }
            }
            
            showSettings() {
                alert('Live conversation settings:\n\n• Speak naturally - no need to pause\n• AI responds immediately\n• Use mute button to temporarily stop input\n• Use "Test Text" to verify connection\n• Clear chat to reset conversation history');
            }
            
            async playWithWebAudio(arrayBuffer) {
                return new Promise((resolve, reject) => {
                    try {
                        if (!this.audioContext || this.audioContext.state === 'closed') {
                            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        }
                        this.audioContext.decodeAudioData(arrayBuffer.slice(0)).then(audioBuffer => {
                            console.log('✅ WebAudio decoded duration', audioBuffer.duration, 'sampleRate', audioBuffer.sampleRate);
                            const source = this.audioContext.createBufferSource();
                            source.buffer = audioBuffer;
                            source.connect(this.audioContext.destination);
                            source.onended = () => {
                                this.onAudioPlaybackEnded();
                                resolve(true);
                            };
                            source.start(0);
                        }).catch(err => {
                            console.warn('WebAudio decodeAudioData failed', err.message);
                            resolve(false);
                        });
                    } catch(err){
                        console.error('playWithWebAudio error', err);
                        resolve(false);
                    }
                });
            }
        }
        
        // Initialize the live voice assistant when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new LiveVoiceAssistant();
        });
    </script>
</body>
</html> 